%Pakete;
%A4, Report, 12pt
\documentclass[ngerman,a4paper,12pt]{scrreprt}
\usepackage[a4paper, right=20mm, left=20mm,top=30mm, bottom=30mm, marginparsep=5mm, marginparwidth=5mm, headheight=7mm, headsep=15mm,footskip=15mm]{geometry}

%Papierausrichtungen
\usepackage{pdflscape}
\usepackage{lscape}

%Deutsche Umlaute, Schriftart, Deutsche Bezeichnungen
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

%quellcode
\usepackage{listings}

%tabellen
\usepackage{tabularx}

%listen und aufzählungen
\usepackage{paralist}

%farben
\usepackage[svgnames,table,hyperref]{xcolor}

%symbole
\usepackage{latexsym,textcomp}
\usepackage{amssymb}

%font
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

%durch- und unterstreichen
\usepackage{ulem}

%Abkürzungsverzeichnisse
\usepackage[printonlyused]{acronym}

%Bilder
\usepackage{graphicx} %Bilder
\usepackage{float}	  %"Floating" Objects, Bilder, Tabellen...
\usepackage[space]{grffile} %Leerzechen Problem bei includegraphics
\usepackage{wallpaper} %Seitenhintergrund setzen
\usepackage{transparent} %Transparenz

%Tikz, Mindmaps, Trees
\usepackage{tikz}
\usetikzlibrary{mindmap,trees}
\usepackage{verbatim}

%for
\usepackage{forloop}
\usepackage{ifthen}

%Dokumenteigenschaften
\title{Summary Vss}
\author{Tobias Blaser}
\date{\today{}, Uster}


%Kopf- /Fusszeile
\usepackage{fancyhdr}
\usepackage{lastpage}

\pagestyle{fancy}
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie

%Kopf-/ Fusszeile auf chapter page
\fancypagestyle{plain} {
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie
}

\usepackage{changepage}

% Abkürzungen für Kapitel, Titel und Listen
\input{commands/shortcutsListAndChapter}
\input{commands/TextStructuringBoxes}

%links, verlinktes Inhaltsverzeichnis, PDF Inhaltsverzeichnis
\usepackage[bookmarks=true,
bookmarksopen=true,
bookmarksnumbered=true,
breaklinks=true,
colorlinks=true,
linkcolor=black,
anchorcolor=black,
citecolor=black,
filecolor=black,
menucolor=black,
pagecolor=black,
urlcolor=black
]{hyperref} % Paket muss unbedingt als letzes eingebunden werden!

\usepackage{graphicx}
\begin{document}

% Inhaltsverzeichnis
\tableofcontents
\clearpage

\ch{Verteilte Systeme}

\definition{Verteilte Systeme}{Zusammenarbeit von Komponenten auf vernetzten Rechnern, die sich durch Nachrichtenaustausch koordinieren.}

Konsequenzen:
\ul
	\li Komponenten können nebenläufig arbeiten.
	\li Komponenten können unabhängig voneinander ausfallen.
	\li Es gibt keine globale Uhr. 
	\li Es ist schwierig einen globalen Zustand zu definieren.
\ulE

\expl{Logische Clock}{Threads, die sich synchronisieren, keine reale Uhr}
Keine Globale Uhr:
\ul
	\li Aktionen / Events, die zu einem bestimmten Zeitpunkt ausgelöst werden, müssen koordiniert werden.
	\li Zwei Rechner in einem Netz besitzen fast nie exakt die selbe Zeit.
	\li Wie könnte man dies überhaupt prüfen? Die Signalzeiten sind ja nur statistisch bekannt.
\ulE

\se{Herausforderungen verteilter Systeme}
\ul
	\li Nebenläufigkeit / Concurrency
	\li Fehlerverarbeitung / Fehlertoleranz
	\li Sicherheit
	\li Offenheit
	\li Heterogenität
	\li Skalierbarkeit
	\li Transparenz (Verbergen der Komplexität)
\ulE

\se{CAP Theroem}
\definition{CAP-Theorem}{ein verteiltes System kann zwei der folgenden
Eigenschaften gleichzeitig erfüllen, jedoch nicht alle drei.}

\ul
	\li Konsistenz (C): Alle Knoten sehen zur selben Zeit dieselben Daten. Diese
Konsistenz sollte nicht verwechselt werden mit der Konsistenz aus der
ACID-Transaktionen, die nur die innere Konsistenz eines Datenbestandes
betrifft.
	\li Verfügbarkeit (A): Alle Anfragen an das System werden stets beantwortet.
	\li Partitionstoleranz (P): Das System arbeitet auch bei Verlust von
Nachrichten, einzelner Netzknoten oder Partition des Netzes weiter.
	\li Da nur zwei dieser drei Anforderungen in verteilten Systemen gleichzeitig
vollständig erfüllt sein können, wird das CAP-Theorem oft als Dreieck
visualisiert, bei dem eine konkrete Anwendung sich auf eine der Kanten
einordnen lässt.Die System-Eigenschaften C, A und P können dabei als
graduelle Grössen gesehen werden.

\ulE

\se{Offenheit}
Verteilte Systeme müssen offen sein
\ul
	\li Notwendig für Anpassungen und Erweiterungen an neue Anforderungen
	\li Mittel zu offenen Systemen
		\ul
			\li Schnittstelln
			\li EInheitliche Kommunkationsmechanismen
		\ulE
\ulE

\se{Sicherheit}
\ul
	\li Vertraulichkeit:
 \ra Daten können nur von dem
gewünschten Empfänger gelesen werden.
\li Integrität: \ra
Die Daten wurden während der
Übertragung nicht verändert.
\li Authentizität: \ra
Die Daten wurden tatsächlich
von der Person gesendet, die behauptet, der Sender zu sein.
\li Verfügbarkeit: \ra
Ein Dienst darf durch eine (Denial of Service) Attacke nicht außer Kraft
gesetzt werden.
\li Sicherheit für mobilen Code: \ra
Mobiler Code darf die lokale Ressource nicht beschädigen und
umgekehrt.

\ulE

\se{Skalierbarkeit}
\expl{Skalierbarkeit}{Algorithmen, Protokolle und Prozeduren, die mit einigen wenigen
Systemkomponenten gut funktionieren (effektiv und effizient), sollen
auch mit vielen Komponenten gut funktionieren, skalierbar sein.
}

\se{Fehlertoleranz}

\se{Nebenläufigkeit}

\se{Transparenz}


\ch{Systemmodelle}
\exam{Systemmodell relevant für Prüfung}

\expl{Architekturmodell}{beschreibt Beziehungen und Verteilung von Komponenten in einem verteilten Syste}

\se{Systemarchitekturen}
\sse{Client-Server}
\img{img/v1.1.jpg}{}{0.75}{}

\sse{Mehrfache Server}
\img{img/v1.2.jpg}{}{0.75}{}

\sse{Proxy-Server und Cache}
\img{img/v1.3.jpg}{}{0.75}{}

\sse{Peer-to-Peer}
\img{img/v1.4.jpg}{}{0.75}{}

\sse{Appets}
\img{img/v1.8.jpg}{}{0.75}{}

\sse{MVC als Architektur Pattern}
Präsentation läuft auf dem Client, Model auf dem Server, Kontrolle über das Netzwerk.

\sse{Three Tier Modell}
\img{img/v1.9.jpg}{}{0.75}{}


\se{Ubiquitäre Systeme}

Mobile Computing: Bewegung ist integraler Bestandteil des
täglichen Lebens. 

\sse{Probleme}
\ul
	\li Schwankungen in Netzqualität
	\li vermindertes Vertrauen und niedrige Robustheit mobiler Endgeräte
	\li Einschränkungen durch Gewicht, Grösse und Batteriekapazität
\ulE

\sse{Grundlagen}
\ul
	\li Mobile Networking mit Mobile IP, AdHoc-Protokollen, ...
	\li Mobile Information Access,...
	\li Energiespartechniken (Speichermanagement, Prozessorscheduling)
	\li Ortsabhängigkeit (GPS, Lokalisierung, Systemverhalten,...)
\ulE

\ul
	\li  Unsichtbarkeit:
	\ra Computertechnologie soll vollständig aus dem Bewusstsein der Nutzer
	verschwinden
	\li Lokale Skalierbarkeit:
	\ra Anstieg der Bandbreite, Energie eines Nutzers und Anstieg der Nutzer
	in einem „Dienstraum“. Lokalität ändert sich rasch und es gibt mehr
	lokale als entfernte Interaktionspartner.
	\li Ausgleich:
	\ra Unterschiedliche Ausstattung unterschiedlicher Diensträume werden
	vom System "homogenisiert.
	\li Information Appliance:
	\ra Rückverlagerung der Funktionalität von Rechnern in die Anwendung.
\ulE

\se{Grundlegende Modelle}

\se{Interaktionsmodell}
\ul
	\li Timing am schwierigsten
	\li Uhren gelten nur lokal
	\li eingeschränkte Kommunikationskanäle (Verzögerungen senden/empfangen, Bandbreitenschwankungen, Jitter)
\ulE

\se{Fehlermodell}
\img{img/v1.5.jpg}{}{0.75}{}

\se{Sicherheitsmodell}
\img{img/v1.6.jpg}{}{0.75}{}
\ul
	\li Prozess Bedrohung (Serverprozess kennt Client zu wenig genau \ra Berechtigungen ungewiss, Client unsicher, ob Antwort wirklich vom Server)
\ulE

\se{RM-ODP Architekturansatz}
Metamodell für offene verteilte Systeme
\img{img/v1.7.jpg}{}{0.75}{}

Systembetrachtung setzt sich aus View Points zusammen (Gesichtswinkeln), weil  sonst zu komplex.

\img{img/v1.10.jpg}{}{0.75}{}
\img{img/v1.11.jpg}{}{0.75}{}

\exam{Beispiel mit File Fetch Java mitnehmen. Beispiel mit Socket kommt garantiert an Prüfung.}

\exam{Objektserialisierung}{Kommt an der Prüfung.}


\ch{Interprozesskommunikation}

\sse{Internetprotokoll}
\ul
	\li UDP: Messagebasiert
	\li TCP: Zweiwegkommunikation
	\li Multicast: Adressieren von Gruppen \\
		Multicast ist sehr unzuverlässig
\ulE

\sse{Sockets}
\ul
	\li Temporäres File, im Hintergrund angelegt
	\li Fehlerbehandlung bei Timeouts / Blocking
	\li Möglichkeiten zur Wiederverwendung
	\li Bei Java und VSS immer zwei Verbindungen: eine für Garbage Collection (überprüfen, was noch lebt) und eine für Trafic
\ulE

\sse{Synchron/Asynchron}
\ul
	\li synchron: send() und receive() sind blockierend
	\li asynchron: receive() kann blockierend oder nicht blockierend sein
\ulE

\sse{Anforderung}
\ul
	\li Zuverlässige Verbindung
	\li  Die Paketreihenfolge bei Empfänger und Sender müssen (idealerweise) gleich sein.
		\ul
			\li  Im Falle von TCP wird dies garantiert
(verbindungsorientierte Kommunikation
[mit ACK, also mit Overhead]).
			\li Im Falle von UDP kann nicht davon ausgegangen werden
(verbindungslose Kommunikation
[ohne ACK, also weniger Overhead]).
		\ulE
\ulE
	
\sse{Adressierung}
\ul
	\li URL: Adresse
	\li URN: Resource Name
	\li URI: Resource Identifier
\ulE
\begin{verbatim}
URI(String scheme, String userInfo, String host, int port, String path, String query, String fragment)
URL ( String protocol, String host, int port, String file, URLStreamHandler handler)
 
\end{verbatim}

\sse{InetAddr}
Kann man nicht setzen, weil IP Adresse vom Netz vergeben wird (dhcp) oder durch den Sysadmin fix festgelegt wurde.

\sse{Sockets und Ports}
\img{img/v2.1.jpg}{}{0.75}{}
Ports sind Protokollgebunden

\exam{UDP/TCP Gateway}
\img{img/v2.2.jpg}{}{0.75}{}

\exam{Ping mit einem andern Protokoll umsetzen}

\sse{IP}
\ul
	\li verbindungslos
	\li End-zu-End übertragung
	\li Best Effort
	\li Fehlermodell: Paketverlust, Duplikate, vertauschte Reihenfolge \\
		Fehler in tieferen Layern treten auch in IP auf
\ulE

\se{UDP Sockets}
Klasse: DatagramPacket, DatagramSocket \\
Methoden: send(DatagramPacket), receive(DatagramPacket)

\ul
	\li Receive/Send in Threads trennen, damit sich die nicht stören.
	\li Fehlermodell: Nachricht wird verworfen, Nachricht geht verloren, Reihenfolge nicht garantiert
	\li Applikation muss sicherstellen, dass Pakete korrekt und in Reihenfolge ankommen
\ulE
\img{img/v2.3.jpg}{Struktur eines UDP Programms}{0.75}{}

\sss{Datagramaufbau}
\ul
	\li Die Adresse Absenders / Die Adresse des Empfängers
 	\li Die Länge der Nachricht
 	\li Die Daten
 	\li Den remote Port.
\ulE

Absenderadresse kann nicht gesetzt werden.
\img{img/v2.4.jpg}{UDP Sender}{1}{}
\img{img/v2.5.jpg}{UDP Empfänger}{1}{}

\se{TCP}
\ul
	\li retransmit bei verlorenen
	\li ServerSocket: passiv, erwartet Verbindungsanfragen
	\li Socket: aktiv, wird vom Client genutzt
\ulE
\img{img/v2.6.jpg}{}{0.75}{}
\img{img/v2.7.jpg}{Server Socket multithreaded Beispiel}{1}{}
\img{img/v2.8.jpg}{Socket Client}{1}{}

\expl{Java Sockets}{Java Sockets sind nur eine Schicht für die Netzwerk Libraries des Betriebsystems. Im Hintergrund werden die Lib's geladen und verwendet.}

\se{Gruppenkommunikation}
\exam{Gruppenkommunikation Kommt eine Prüfungsaufgabe}
\ul
	\li basiert oft auf Multicasting (1:n Kommunikation)
	\li Herausfinden, wer in Multicastgruppe ist: Ping, ist aber unzuverlässig
	\li jGroups läuft über TCP\\
		join() und leave() zum beitreten und verlassen
\ulE
\img{img/v2.9.jpg}{}{0.25}{}
\img{img/v2.10.jpg}{IP Multicast}{0.75}{}
\img{img/v2.11.jpg}{IP Multicast}{1}{}


\se{Intern/Extern}
\img{img/v2.12.jpg}{}{0.75}{}
Probleme mit interner Datendarstellung \ra Verwendung einer externen Darstellung

\sse{Java Objektserialisierung}
\img{img/v2.13.jpg}{}{1}{}
\ul
	\li einfach
	\li private attribute einsehbar! \ra Kennzeichnungspflicht
\ulE

\sss{Interfaces}
\img{img/v2.14.jpg}{}{1}{}
\img{img/v2.15.jpg}{}{0.75}{}

\sss{Probleme}
\ul
	\li Objektserialisierer schaut nach, ob Referenzen gleich sind. Hat man in der zwischenzeit etwas geändert, wird das schon geschrieben Objekt im Stream ohne die Änderungen nochmals verwendet. \ra writeReplace() verwenden
	\li Transient Attribute nicht serialisierbar
	\li Childklassen von deriaisierbaren Klassen sind automatisch auch serialisierbar. Kann jedoch abgemurkst werden.
\ulE

\sss{Java2XML}
\img{img/v2.16.jpg}{Java 2 XML}{1}{}
\img{img/v2.17.jpg}{}{1}{}

\sse{Referenzierung von externen Objekten}
\ul
	\li Objektreferenz muss in VSS eindeutig sein
	\li Referenzen dürfen nicht wiederverwendet werden
	
\ulE
\exam{Sockets genau anschauen, sind Prüfungsrelevant}


\ch{Verteilte Objekte und entfernte Aufrufe}
\se{RRA Protokol}
\img{img/v3.1.jpg}{}{0.75}{}
\ul
	\li Client wartet bis Antwort da ist
	\li Fehlermodell: 
		\ul
			\li Server kann überlastet oder down sein, Dienstverweigerung \\
				\ul
					\li Arbeiten mit Timeouts
					\li Mehrfacher Requestversuch \ra Problem mit mehrfacher Antwort
				\ulE
			\li Kommandreihenfolge kann durcheinander geraten
			\li Mehrfache Antwort \ra Server könnte History führen
			\li Nachrichten können verloren gehen \ra Server sendet Nachricht nochmal
		\ulE
\ulE
\img{img/v3.2.jpg}{}{0.75}{}

\sse{Aufrufsemantik}
\img{img/v3.3.jpg}{}{0.75}{}

\sss{At least once}
Mit Sicherheit eine Antwort, es können jedoch mehrere verschiedene Antworten vorliegen
\img{img/v3.4.jpg}{At least once Semantik}{0.75}{}

\sss{At most once}
Requests werden gespeichert, Immer gleiches Resultat
\img{img/v3.5.jpg}{}{0.75}{}

\sss{Fehlersemantik}
\img{img/v3.6.jpg}{}{0.75}{}

\sse{RRA Kombinationen}
\ul
	\li R: Request \\ Der Client sendet eine Anfrage an den Server (und verändert damit
u.U. dessen Zustand).
	\li RR: Request / Reply\\Der Client erhält eine Antwort auf seine Anfrage, aber bestätigt den
Empfang nicht.\\Beispiel: GET /index.html im HTTP Protokoll.
	 \li RRA: Request / Reply / Acknowledge\\In diesem Fall sendet der Client eine Empfangsbestätigung an den
Server.
\ulE

\se{Remote Proceure Call}
\ul
	\li Service wird hinter Interface versteckt (Remote Interface) \\
	\ra Interface muss für Client und Server gemeinsam sein.
	\li Remote Zugriff auf lokale Variablen nicht sinnvoll \ra unterschiedliche Adressen
	\li Call bei value empfehlenswert, Call bei Reference problematisch\\
	\ra Gemeinsam genutzte Objekte könnten Call by Reference ermöglichen
\ulE

\sse{Remote Schnittstelle IDL}
\img{img/v3.7.jpg}{Corba IDL}{0.75}{}
\ul
	\li Analog Programmiersprache aufgebaut
\ulE

\examp{Sun RPC}{
	\ul
		\li Bind Service
		\li Programme werden durchnummeriert
	\ulE
	\img{img/v3.8.jpg}{}{0.75}{}
}

\img{img/v3.9.jpg}{}{0.75}{}
\img{img/v3.10.jpg}{RPC}{0.75}{}
\img{img/v3.11.jpg}{CORBA - Zweimal RPC: Client-Broker und Broker-Server}{0.75}{}

\se{RMI}
\ul
	\li Methode ist es ansehbar, ob sie lokal oder remote ist
	\li 
\ulE
\img{img/v3.12.jpg}{Verteiltes System}{0.75}{}
\img{img/v3.13.jpg}{Unterschied Prozedur und Methode}{0.75}{}
\img{img/v3.14.jpg}{}{0.75}{}
\img{img/v3.15.jpg}{}{0.75}{}

\sse{RMI Java Beispiel}
\img{img/v3.16.jpg}{Remote Interface Beispiel}{0.75}{}
\img{img/v3.17.jpg}{Aufbau Server Infrastruktur}{0.5}{}
\img{img/v3.18.jpg}{Remote Service}{0.75}{}
\exam{Warum beendet sich der Server nicht gleich selbst, obwohl er an der letzten Zeile angelangt ist? Durch den export wurde der Server an die Middleware gebunden. WIrd die Middleware gestoppt, stirbt der Server.}

\expl{Remoting (Zusammenfassung)}{
\ul
	\li Aufrufe wie lokal aber als remote markiert
	\li Kommunikation: Proxies
	\li Namensdienst wird benötigt: Registry
	\li Security sehr wichtig
\ulE
}








\end{document}

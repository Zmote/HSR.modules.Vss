%Pakete;
%A4, Report, 12pt
\documentclass[ngerman,a4paper,12pt]{scrreprt}
\usepackage[a4paper, right=20mm, left=20mm,top=30mm, bottom=30mm, marginparsep=5mm, marginparwidth=5mm, headheight=7mm, headsep=15mm,footskip=15mm]{geometry}

%Papierausrichtungen
\usepackage{pdflscape}
\usepackage{lscape}

%Deutsche Umlaute, Schriftart, Deutsche Bezeichnungen
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

%quellcode
\usepackage{listings}

%tabellen
\usepackage{tabularx}

%listen und aufzählungen
\usepackage{paralist}

%farben
\usepackage[svgnames,table,hyperref]{xcolor}

%symbole
\usepackage{latexsym,textcomp}
\usepackage{amssymb}

%font
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

%durch- und unterstreichen
\usepackage{ulem}

%Abkürzungsverzeichnisse
\usepackage[printonlyused]{acronym}

%Bilder
\usepackage{graphicx} %Bilder
\usepackage{float}	  %"Floating" Objects, Bilder, Tabellen...
\usepackage[space]{grffile} %Leerzechen Problem bei includegraphics
\usepackage{wallpaper} %Seitenhintergrund setzen
\usepackage{transparent} %Transparenz

%Tikz, Mindmaps, Trees
\usepackage{tikz}
\usetikzlibrary{mindmap,trees}
\usepackage{verbatim}

%for
\usepackage{forloop}
\usepackage{ifthen}

%Dokumenteigenschaften
\title{Summary Vss}
\author{Tobias Blaser}
\date{\today{}, Uster}


%Kopf- /Fusszeile
\usepackage{fancyhdr}
\usepackage{lastpage}

\pagestyle{fancy}
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie

%Kopf-/ Fusszeile auf chapter page
\fancypagestyle{plain} {
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie
}

\usepackage{changepage}

% Abkürzungen für Kapitel, Titel und Listen
\input{commands/shortcutsListAndChapter}
\input{commands/TextStructuringBoxes}

%links, verlinktes Inhaltsverzeichnis, PDF Inhaltsverzeichnis
\usepackage[bookmarks=true,
bookmarksopen=true,
bookmarksnumbered=true,
breaklinks=true,
colorlinks=true,
linkcolor=black,
anchorcolor=black,
citecolor=black,
filecolor=black,
menucolor=black,
pagecolor=black,
urlcolor=black
]{hyperref} % Paket muss unbedingt als letzes eingebunden werden!

\usepackage{graphicx}
\begin{document}

% Inhaltsverzeichnis
\tableofcontents
\clearpage

\ch{Verteilte Systeme}

\definition{Verteilte Systeme}{Zusammenarbeit von Komponenten auf vernetzten Rechnern, die sich durch Nachrichtenaustausch koordinieren.}

Konsequenzen:
\ul
	\li Komponenten können nebenläufig arbeiten.
	\li Komponenten können unabhängig voneinander ausfallen.
	\li Es gibt keine globale Uhr. 
	\li Es ist schwierig einen globalen Zustand zu definieren.
\ulE

\expl{Logische Clock}{Threads, die sich synchronisieren, keine reale Uhr}
Keine Globale Uhr:
\ul
	\li Aktionen / Events, die zu einem bestimmten Zeitpunkt ausgelöst werden, müssen koordiniert werden.
	\li Zwei Rechner in einem Netz besitzen fast nie exakt die selbe Zeit.
	\li Wie könnte man dies überhaupt prüfen? Die Signalzeiten sind ja nur statistisch bekannt.
\ulE

\se{Herausforderungen verteilter Systeme}
\ul
	\li Nebenläufigkeit / Concurrency
	\li Fehlerverarbeitung / Fehlertoleranz
	\li Sicherheit
	\li Offenheit
	\li Heterogenität
	\li Skalierbarkeit
	\li Transparenz (Verbergen der Komplexität)
\ulE

\se{CAP Theroem}
\definition{CAP-Theorem}{ein verteiltes System kann zwei der folgenden
Eigenschaften gleichzeitig erfüllen, jedoch nicht alle drei.}

\ul
	\li Konsistenz (C): Alle Knoten sehen zur selben Zeit dieselben Daten. Diese
Konsistenz sollte nicht verwechselt werden mit der Konsistenz aus der
ACID-Transaktionen, die nur die innere Konsistenz eines Datenbestandes
betrifft.
	\li Verfügbarkeit (A): Alle Anfragen an das System werden stets beantwortet.
	\li Partitionstoleranz (P): Das System arbeitet auch bei Verlust von
Nachrichten, einzelner Netzknoten oder Partition des Netzes weiter.
	\li Da nur zwei dieser drei Anforderungen in verteilten Systemen gleichzeitig
vollständig erfüllt sein können, wird das CAP-Theorem oft als Dreieck
visualisiert, bei dem eine konkrete Anwendung sich auf eine der Kanten
einordnen lässt.Die System-Eigenschaften C, A und P können dabei als
graduelle Grössen gesehen werden.

\ulE

\se{Offenheit}
Verteilte Systeme müssen offen sein
\ul
	\li Notwendig für Anpassungen und Erweiterungen an neue Anforderungen
	\li Mittel zu offenen Systemen
		\ul
			\li Schnittstelln
			\li EInheitliche Kommunkationsmechanismen
		\ulE
\ulE

\se{Sicherheit}
\ul
	\li Vertraulichkeit:
 \ra Daten können nur von dem
gewünschten Empfänger gelesen werden.
\li Integrität: \ra
Die Daten wurden während der
Übertragung nicht verändert.
\li Authentizität: \ra
Die Daten wurden tatsächlich
von der Person gesendet, die behauptet, der Sender zu sein.
\li Verfügbarkeit: \ra
Ein Dienst darf durch eine (Denial of Service) Attacke nicht außer Kraft
gesetzt werden.
\li Sicherheit für mobilen Code: \ra
Mobiler Code darf die lokale Ressource nicht beschädigen und
umgekehrt.

\ulE

\se{Skalierbarkeit}
\expl{Skalierbarkeit}{Algorithmen, Protokolle und Prozeduren, die mit einigen wenigen
Systemkomponenten gut funktionieren (effektiv und effizient), sollen
auch mit vielen Komponenten gut funktionieren, skalierbar sein.
}

\se{Fehlertoleranz}

\se{Nebenläufigkeit}

\se{Transparenz}


\ch{Systemmodelle}
\exam{Systemmodell relevant für Prüfung}

\expl{Architekturmodell}{beschreibt Beziehungen und Verteilung von Komponenten in einem verteilten Syste}

\se{Systemarchitekturen}
\sse{Client-Server}
\img{img/v1.1.jpg}{}{0.75}{}

\sse{Mehrfache Server}
\img{img/v1.2.jpg}{}{0.75}{}

\sse{Proxy-Server und Cache}
\img{img/v1.3.jpg}{}{0.75}{}

\sse{Peer-to-Peer}
\img{img/v1.4.jpg}{}{0.75}{}

\sse{Appets}
\img{img/v1.8.jpg}{}{0.75}{}

\sse{MVC als Architektur Pattern}
Präsentation läuft auf dem Client, Model auf dem Server, Kontrolle über das Netzwerk.

\sse{Three Tier Modell}
\img{img/v1.9.jpg}{}{0.75}{}


\se{Ubiquitäre Systeme}

Mobile Computing: Bewegung ist integraler Bestandteil des
täglichen Lebens. 

\sse{Probleme}
\ul
	\li Schwankungen in Netzqualität
	\li vermindertes Vertrauen und niedrige Robustheit mobiler Endgeräte
	\li Einschränkungen durch Gewicht, Grösse und Batteriekapazität
\ulE

\sse{Grundlagen}
\ul
	\li Mobile Networking mit Mobile IP, AdHoc-Protokollen, ...
	\li Mobile Information Access,...
	\li Energiespartechniken (Speichermanagement, Prozessorscheduling)
	\li Ortsabhängigkeit (GPS, Lokalisierung, Systemverhalten,...)
\ulE

\ul
	\li  Unsichtbarkeit:
	\ra Computertechnologie soll vollständig aus dem Bewusstsein der Nutzer
	verschwinden
	\li Lokale Skalierbarkeit:
	\ra Anstieg der Bandbreite, Energie eines Nutzers und Anstieg der Nutzer
	in einem „Dienstraum“. Lokalität ändert sich rasch und es gibt mehr
	lokale als entfernte Interaktionspartner.
	\li Ausgleich:
	\ra Unterschiedliche Ausstattung unterschiedlicher Diensträume werden
	vom System "homogenisiert.
	\li Information Appliance:
	\ra Rückverlagerung der Funktionalität von Rechnern in die Anwendung.
\ulE

\se{Grundlegende Modelle}

\se{Interaktionsmodell}
\ul
	\li Timing am schwierigsten
	\li Uhren gelten nur lokal
	\li eingeschränkte Kommunikationskanäle (Verzögerungen senden/empfangen, Bandbreitenschwankungen, Jitter)
\ulE

\se{Fehlermodell}
\img{img/v1.5.jpg}{}{0.75}{}

\se{Sicherheitsmodell}
\img{img/v1.6.jpg}{}{0.75}{}
\ul
	\li Prozess Bedrohung (Serverprozess kennt Client zu wenig genau \ra Berechtigungen ungewiss, Client unsicher, ob Antwort wirklich vom Server)
\ulE

\se{RM-ODP Architekturansatz}
Metamodell für offene verteilte Systeme
\img{img/v1.7.jpg}{}{0.75}{}

Systembetrachtung setzt sich aus View Points zusammen (Gesichtswinkeln), weil  sonst zu komplex.

\img{img/v1.10.jpg}{}{0.75}{}
\img{img/v1.11.jpg}{}{0.75}{}

\exam{Beispiel mit File Fetch Java mitnehmen. Beispiel mit Socket kommt garantiert an Prüfung.}

\exam{Objektserialisierung}{Kommt an der Prüfung.}


\ch{Interprozesskommunikation}

\sse{Internetprotokoll}
\ul
	\li UDP: Messagebasiert
	\li TCP: Zweiwegkommunikation
	\li Multicast: Adressieren von Gruppen \\
		Multicast ist sehr unzuverlässig
\ulE

\sse{Sockets}
\ul
	\li Temporäres File, im Hintergrund angelegt
	\li Fehlerbehandlung bei Timeouts / Blocking
	\li Möglichkeiten zur Wiederverwendung
	\li Bei Java und VSS immer zwei Verbindungen: eine für Garbage Collection (überprüfen, was noch lebt) und eine für Trafic
\ulE

\sse{Synchron/Asynchron}
\ul
	\li synchron: send() und receive() sind blockierend
	\li asynchron: receive() kann blockierend oder nicht blockierend sein
\ulE

\sse{Anforderung}
\ul
	\li Zuverlässige Verbindung
	\li  Die Paketreihenfolge bei Empfänger und Sender müssen (idealerweise) gleich sein.
		\ul
			\li  Im Falle von TCP wird dies garantiert
(verbindungsorientierte Kommunikation
[mit ACK, also mit Overhead]).
			\li Im Falle von UDP kann nicht davon ausgegangen werden
(verbindungslose Kommunikation
[ohne ACK, also weniger Overhead]).
		\ulE
\ulE
	
\sse{Adressierung}
\ul
	\li URL: Adresse
	\li URN: Resource Name
	\li URI: Resource Identifier
\ulE
\begin{verbatim}
URI(String scheme, String userInfo, String host, int port, String path, String query, String fragment)
URL ( String protocol, String host, int port, String file, URLStreamHandler handler)
 
\end{verbatim}

\sse{InetAddr}
Kann man nicht setzen, weil IP Adresse vom Netz vergeben wird (dhcp) oder durch den Sysadmin fix festgelegt wurde.

\sse{Sockets und Ports}
\img{img/v2.1.jpg}{}{0.75}{}
Ports sind Protokollgebunden

\exam{UDP/TCP Gateway}
\img{img/v2.2.jpg}{}{0.75}{}

\exam{Ping mit einem andern Protokoll umsetzen}

\sse{IP}
\ul
	\li verbindungslos
	\li End-zu-End übertragung
	\li Best Effort
	\li Fehlermodell: Paketverlust, Duplikate, vertauschte Reihenfolge \\
		Fehler in tieferen Layern treten auch in IP auf
\ulE

\se{UDP Sockets}
Klasse: DatagramPacket, DatagramSocket \\
Methoden: send(DatagramPacket), receive(DatagramPacket)

\ul
	\li Receive/Send in Threads trennen, damit sich die nicht stören.
	\li Fehlermodell: Nachricht wird verworfen, Nachricht geht verloren, Reihenfolge nicht garantiert
	\li Applikation muss sicherstellen, dass Pakete korrekt und in Reihenfolge ankommen
\ulE
\img{img/v2.3.jpg}{Struktur eines UDP Programms}{0.75}{}

\sss{Datagramaufbau}
\ul
	\li Die Adresse Absenders / Die Adresse des Empfängers
 	\li Die Länge der Nachricht
 	\li Die Daten
 	\li Den remote Port.
\ulE

Absenderadresse kann nicht gesetzt werden.
\img{img/v2.4.jpg}{UDP Sender}{1}{}
\img{img/v2.5.jpg}{UDP Empfänger}{1}{}

\se{TCP}
\ul
	\li retransmit bei verlorenen
	\li ServerSocket: passiv, erwartet Verbindungsanfragen
	\li Socket: aktiv, wird vom Client genutzt
\ulE
\img{img/v2.6.jpg}{}{0.75}{}
\img{img/v2.7.jpg}{Server Socket multithreaded Beispiel}{1}{}
\img{img/v2.8.jpg}{Socket Client}{1}{}

\expl{Java Sockets}{Java Sockets sind nur eine Schicht für die Netzwerk Libraries des Betriebsystems. Im Hintergrund werden die Lib's geladen und verwendet.}

\se{Gruppenkommunikation}
\exam{Gruppenkommunikation Kommt eine Prüfungsaufgabe}
\ul
	\li basiert oft auf Multicasting (1:n Kommunikation)
	\li Herausfinden, wer in Multicastgruppe ist: Ping, ist aber unzuverlässig
	\li jGroups läuft über TCP\\
		join() und leave() zum beitreten und verlassen
\ulE
\img{img/v2.9.jpg}{}{0.25}{}
\img{img/v2.10.jpg}{IP Multicast}{0.75}{}
\img{img/v2.11.jpg}{IP Multicast}{1}{}


\se{Intern/Extern}
\img{img/v2.12.jpg}{}{0.75}{}
Probleme mit interner Datendarstellung \ra Verwendung einer externen Darstellung

\sse{Java Objektserialisierung}
\img{img/v2.13.jpg}{}{1}{}
\ul
	\li einfach
	\li private attribute einsehbar! \ra Kennzeichnungspflicht
\ulE

\sss{Interfaces}
\img{img/v2.14.jpg}{}{1}{}
\img{img/v2.15.jpg}{}{0.75}{}

\sss{Probleme}
\ul
	\li Objektserialisierer schaut nach, ob Referenzen gleich sind. Hat man in der zwischenzeit etwas geändert, wird das schon geschrieben Objekt im Stream ohne die Änderungen nochmals verwendet. \ra writeReplace() verwenden
	\li Transient Attribute nicht serialisierbar
	\li Childklassen von deriaisierbaren Klassen sind automatisch auch serialisierbar. Kann jedoch abgemurkst werden.
\ulE

\sss{Java2XML}
\img{img/v2.16.jpg}{Java 2 XML}{1}{}
\img{img/v2.17.jpg}{}{1}{}

\sse{Referenzierung von externen Objekten}
\ul
	\li Objektreferenz muss in VSS eindeutig sein
	\li Referenzen dürfen nicht wiederverwendet werden
	
\ulE
\exam{Sockets genau anschauen, sind Prüfungsrelevant}


\ch{Verteilte Objekte und entfernte Aufrufe}
\se{RRA Protokol}
\img{img/v3.1.jpg}{}{0.75}{}
\ul
	\li Client wartet bis Antwort da ist
	\li Fehlermodell: 
		\ul
			\li Server kann überlastet oder down sein, Dienstverweigerung \\
				\ul
					\li Arbeiten mit Timeouts
					\li Mehrfacher Requestversuch \ra Problem mit mehrfacher Antwort
				\ulE
			\li Kommandreihenfolge kann durcheinander geraten
			\li Mehrfache Antwort \ra Server könnte History führen
			\li Nachrichten können verloren gehen \ra Server sendet Nachricht nochmal
		\ulE
\ulE
\img{img/v3.2.jpg}{}{0.75}{}

\sse{Aufrufsemantik}
\img{img/v3.3.jpg}{}{0.75}{}

\sss{At least once}
Mit Sicherheit eine Antwort, es können jedoch mehrere verschiedene Antworten vorliegen
\img{img/v3.4.jpg}{At least once Semantik}{0.75}{}

\sss{At most once}
Requests werden gespeichert, Immer gleiches Resultat
\img{img/v3.5.jpg}{}{0.75}{}

\sss{Fehlersemantik}
\img{img/v3.6.jpg}{}{0.75}{}

\sse{RRA Kombinationen}
\ul
	\li R: Request \\ Der Client sendet eine Anfrage an den Server (und verändert damit
u.U. dessen Zustand).
	\li RR: Request / Reply\\Der Client erhält eine Antwort auf seine Anfrage, aber bestätigt den
Empfang nicht.\\Beispiel: GET /index.html im HTTP Protokoll.
	 \li RRA: Request / Reply / Acknowledge\\In diesem Fall sendet der Client eine Empfangsbestätigung an den
Server.
\ulE

\se{Remote Proceure Call}
\ul
	\li Service wird hinter Interface versteckt (Remote Interface) \\
	\ra Interface muss für Client und Server gemeinsam sein.
	\li Remote Zugriff auf lokale Variablen nicht sinnvoll \ra unterschiedliche Adressen
	\li Call bei value empfehlenswert, Call bei Reference problematisch\\
	\ra Gemeinsam genutzte Objekte könnten Call by Reference ermöglichen
\ulE

\sse{Remote Schnittstelle IDL}
\img{img/v3.7.jpg}{Corba IDL}{0.75}{}
\ul
	\li Analog Programmiersprache aufgebaut
\ulE

\examp{Sun RPC}{
	\ul
		\li Bind Service
		\li Programme werden durchnummeriert
	\ulE
	\img{img/v3.8.jpg}{}{0.75}{}
}

\img{img/v3.9.jpg}{}{0.75}{}
\img{img/v3.10.jpg}{RPC}{0.75}{}
\img{img/v3.11.jpg}{CORBA - Zweimal RPC: Client-Broker und Broker-Server}{0.75}{}

\se{RMI}
\ul
	\li Methode ist es ansehbar, ob sie lokal oder remote ist
	\li 
\ulE
\img{img/v3.12.jpg}{Verteiltes System}{0.75}{}
\img{img/v3.13.jpg}{Unterschied Prozedur und Methode}{0.75}{}
\img{img/v3.14.jpg}{}{0.75}{}
\img{img/v3.15.jpg}{}{0.75}{}

\sse{RMI Java Beispiel}
\img{img/v3.16.jpg}{Remote Interface Beispiel}{0.75}{}
\img{img/v3.17.jpg}{Aufbau Server Infrastruktur}{0.5}{}
\img{img/v3.18.jpg}{Remote Service}{0.75}{}
\exam{Warum beendet sich der Server nicht gleich selbst, obwohl er an der letzten Zeile angelangt ist? Durch den export wurde der Server an die Middleware gebunden. WIrd die Middleware gestoppt, stirbt der Server.}

\expl{Remoting (Zusammenfassung)}{
\ul
	\li Aufrufe wie lokal aber als remote markiert
	\li Kommunikation: Proxies
	\li Namensdienst wird benötigt: Registry
	\li Security sehr wichtig
\ulE
}

\se{RMI Details}
\img{img/v5.1.jpg}{}{1}{}
\expl{Registry}{Stirbt die Registry zwischen dem Lookup und dem Aufruf der Remote Procedure, so passiert nichts, weil der Client den Proxy bereits erstellt hat. Startet man anschliessend die Registry neu, so muss man den Server auch neu starten, damit er sich wieder einträgt. \ra RMI Registry ist nicht restartfähig weil Hashtabelle nur im Memory abgelegt wird.}

\img{img/v4.1.jpg}{}{0.75}{}

\expl{Connection Refused}{Typische Socket Fehlermeldung. Desto tiefer im Stack die Fehlermeldung, desto kryptischer ist sie.}

\img{img/v4.2.jpg}{}{0.75}{}
\img{img/v4.3.jpg}{Client kommuniziert mit Proxy wie mit einem normalen lokalen Objekt. Der Proxy übernimmt den Rest (Remote call, Garbage Collection, ...)}{0.75}{}
\img{img/v4.4.jpg}{}{1}{}

\expl{Dispatcher}{Dispatcher ist dafür verantwortlich, dass die Calls entsprechend verteilt werden.
	\ol
		\li Gesendet wird nummer von Operation. Server entscheidet mit switch anhand Nummer, welche Operation Ausgeführt wird. 
		\li Server holt Parameter aus Inputstream, schliesst diesen. 
		\li Server Ruft Methode mit Parameter auf. Server holt vom Call einen Resultstream und schreibt das Resultat zurück.
	\olE
}

\ul
	\li Durch das Serialisieren eines Objektes und Versenden wird bereits automatisch Call bei Value gemacht (weil Kopie).
\ulE
\img{img/v4.5.jpg}{Codebase muss auf Interface, nicht auf KLasse verweisen}{0.75}{}
\important{EIn auf dem Server geändertes Objekt wird nicht automatisch an den Client zurückgesendet!}

\expl{Call by Reference}{Client auch als Parameter mitgeben, damit der Server auf dem Client entsprechende Methoden ausführen kann.}
\img{img/v4.6.jpg}{}{0.75}{}


\se{Dynamic Class Loading}
\img{img/v4.7.jpg}{}{0.75}{}
\img{img/v4.8.jpg}{Interface wird auf Server geladen und Client sowie Server laden es herunter. Zum Compilieren muss das Interface allerdings lokal verfügbar sein.}{0.75}{}

\se{RMI Server schlafen legen}
\ul
	\li Server kann schlafen elegt werden. Aktivierungsklasse (Daemon) weckt den RMI Server.
	\li Anfrage von Client geht an Server (im Hintergrund an Daemon), Daemon weckt Server, führt Anfrage aus, Server geht anschliessend wieder schlafen
\ulE

\exam{RMI Spezifikation überfliegen}


\ch{Indirekte Kommunikation}
\definition{Indirekte Kommunikation}{Geschieht über einen Vermittler, es findet in der Regel keine direkte Kopplung des Consumers an den Producer der Nachrichten statt.}

\se{Multicast}
\img{img/v5.2.jpg}{}{1}{}

\uli{
	\li offene Gruppe: Komunizieren nur unter sich
	\li Offene Gruppe: Kann NAchrichten von aussen erhalten
	\li Zuverlässigkeit:
		\uli{
			\li Zuverlässigkeit bei 1-zu-1 Kommunikation:
				\oli{
					\li Integrität: Die versendete und die empfangene Nachricht sind identisch.
					\li Validität: Jede ausgehende Nachricht wird eventuell abgeliefert.
				}
			\li Zuverlässigkeit bei Multicasting Systemen:
				\oli{
					\li Integrität
					\li Validität
					\li Agreement: Falls eine Meldung an ein Mitglied der Gruppe ausgeliefert wird,
wird sie an alle Mitglieder ausgeliefert.
				}
			}
}

\img{img/v5.3.jpg}{Zuverlässigkeit und Ordnung von Multicast}{0.75}{}

\uli{
	\li Multicast Gruppe kann nicht ermitteln, wer drin ist
	\li Router weiss, wer drin ist
}

\sse{Mitgliedsverwaltung}
\img{img/v5.4.jpg}{Mitgliederverwaltung}{0.75}{}
\exam{Wie kann ich feststellen, ob ein Knoten ausgefallen ist?}

\sse{Pulbic-/Subscribe System}
\img{img/v5.5.jpg}{Messaging System mit Server, Client, Broker und DB}{0.75}{}
\img{img/v5.6.jpg}{}{0.75}{}
\img{img/v5.7.jpg}{Rollen}{0.75}{}

\uli{
	\li Sobald Ereignis eintritt wird diesesn publiziert
	\li Subscriber melden sich beim Publisher an/ab
}
\img{img/v5.8.jpg}{Schematische Darstellung}{0.75}{}
\img{img/v5.9.jpg}{Broker}{0.75}{}
\img{img/v5.10.jpg}{Architektur}{0.75}{}

\se{Message Queues}
\uli{
	\li Producer sendet Nachricht
	\li Receiver Emfängt Nachrichten, indem er sie aus der Warteschlange ausliest
	\uli{
		\li Blockierendes Lesen: Der Receiver wird solange blockiert, bis die Nachricht in der
Warteschlange ist.
		\li Nicht-blockierendes Lesen: polling \\
			Überprüfen der Warteschlange, ob eine Nachricht eingetroffen ist. \\
			Lesen der Nachricht oder einer Meldung, dass nichts da ist.
		\li notify():
	}
}

\img{img/v5.11.jpg}{}{0.75}{}

\sse{JMS}
\img{img/v5.12.jpg}{Daten Distributions Architekturen}{0.75}{}
\img{img/v5.13.jpg}{Virtuell vollverknüpfte Netzwerke}{0.75}{}
\img{img/v5.14.jpg}{P2P Architektur}{0.75}{}
\img{img/v5.15.jpg}{Public/Subscriber Architektur}{0.75}{}

\sse{Connectionfactory}
\img{img/v5.16.jpg}{Connection Factory}{0.75}{}

\expl{Persistence}{Nachrichten können sowohl persistent als auch nicht-persistent verwaltet werden}

\exam{Tupelräume nicht Prüfungsstoff}

\expl{Hauptvorteile gegenüber RMI}{Messaging ist Technologie (Java) unabhängig. Es können verschiedene Formate wie XML, JSON, ... eingesetzt werden. Messaging wird im Unterschied zu RMI fast ausschliesslich für asynchrone Kommunikation verwendet. RMI wird fast immer als synchrone Kommunikation eingesetzt.}
\expl{Nachrichtenaufbewahrung bei P/S Queue}{Der Broker / die Queue ist dafür zuständig, dass alle Empfänger die Nachricht erhalten haben, bevor sie gelöscht wird. }
\expl{Session}{Macht es Sinn, bei Messaging Sessions einzusetzen zwischen der Queue und dem Client/Serer? Nein. Die Kommunikation ist Verbindungslos und daher ist eine Session sinnlos.}

\se{Jini}
\exam{Tupel Spaces / Java Spaces nicht Prüfungsstoff}
\img{img/v6.1.jpg}{}{0.75}{}
\img{img/v6.2.jpg}{Distributed Shared Memory}{0.75}{}
\sse{Java Spaces / Tupelräume}
\uli{
	\li Es werden räume definiert, die über Keywords beschrieben werden. 
	\li Inhalte (Tupel / Objekte) werden ebenfalls mit Schlüsselwörtern versehen
	\li Benutzer können auf Räume Listen und erhalten entsprechend Notifications
	\li Java Spaces unterstützen da ACID Prinzip
}
\img{img/v6.3.jpg}{Java Spaces}{0.75}{}
\img{img/v6.4.jpg}{Rechnerfarm mit Spaces}{0.75}{}


\ch{Verteilte Dateisysteme}
\uli{
	\li Grundprinzip: Daten Sharen
	\li Level1: 1 Benutzer, 1 Prozess, nur lokale Daten
	\li Level2: 1 Benutzer, n Prozesse, nur lokale Daten \ra Concurrency notwendig
	\li Level3: n Benutzer, n Prozesse, nur lokale Daten \ra Security notwendig
	\li Level4: n Benutzer, n Prozesse, verteilte Daten
}
%Folie 7
Probleme bei Verteilten Dateisystemen: Replikation, Caching, Objekt-Persistenz
%Folie 10
%Folie 13
\sse{Anforderungen VDS}
\uli{
	\li Client soll verteilung der Datei nicht kennen
	\li Die Darstellung des Dateisystems soll uniform sein (ein Namesraum / Schema)
	\li Muss Skalierbar sein
	\li Fehlertoleranz
	\li Konsistenz
	\li Sicherheit
	\li Effizienz
	\li Operationen müssen wiederholbar sein, weil es über das Netz Ausfälle geben kann
}
\se{NFS}
%Folie 17
%Folie 20
\uli{
	\li Client Caching: Extrem wichtig, aber ein Problem
	\li Dateidelegation: Server gibt Datei an Client. Sobald eine weitere Anfrage eingeht, fordert der Server den neusten Stand der Datei zurück und entscheidet anschliessend, wer nun darf.
	\li Es werden oft nur Teile der Datei übertragen und gecached.
}

\se{AFS}
\uli{
	\li Weil viele kleine Dateien, werden sie ganz verschoben und als ganzes gecached.
	\li Datei wird komplett heruntergeladen und nach Bearbeitung 
}
% F22
\expl{Unterschied NFS AFS}{NFS arbeitet mit Teilen von Dateien oder Blöcken, AFS sendet immer ganze Dateien an den Client.}


\se{Hadoop Distributed Filesystem HDFS}
\sse{Wichtige Entwurfsaspekte}
\uli{
	\li Effiziente Nutzung des Client- Cachings
	\li Leistung vergleichbar mit lokalen Dateisystemen.
	\li Konsistenzwahrung.
	\li Wiederherstellung bei Abstürzen und Ausfällen.
	\li Hoher Durchsatz.
	\li Skalierbarkeit.
}
\sse{Hadoop Eigenschaften}
\uli{
	\li Dateigrösse sind im Giga- / Tera- / Petabyte Bereich.
	\li Streaming: Write Once, Read Many
	\li Grosse Blöcke (bis 128 MB)
	\li Minimierung von Transfers (lokal anfallende Daten werden lokal behandelt)
	\li Berechnungen geschehen da, wo die Daten sind
	\li Task arbeiten mit so wenigen Blöcken wie möglich
	\li Wenn ein Node ausfällt, wird die Aufgabe delegiert
}
\img{img/v7.1.jpg}{Hadoop Anforderungen}{0.75}{}

\img{img/v7.2.jpg}{Map Reduce}{0.75}{}
\img{img/v7.3.jpg}{Reduce}{0.75}{}

\uli{
	\li Hadoop verwendet die darunter liegenden Dateisysteme
	\li Master/Slave Architektur
}
\img{img/v7.4.jpg}{Datenzugriff}{0.75}{}
\img{img/v7.5.jpg}{Reduce am Beispiel Word Count}{0.75}{}

\sse{Hadoop Architektur}
\img{img/v7.6.jpg}{}{0.75}{}
\img{img/v7.7.jpg}{Cluster Infrastructure}{0.75}{}
\exam{Hadoop Beispiel könnte 1:1 an der Prüfung kommen. Mehr über Dateisysteme wird wohl nicht an der Prüfung kommen.}

\ch{Namensdienste}
\exam{LDAP kommt konkret an der Prüfung}
\uli{
	\li Namen gestatten Zugriff auf Objekte
	\li Context beschreibt Hirarche (Bsp .ch bei DNS)
	\li Verzeichnisdienst ist erweiterung des Namensdienstes
}
\img{img/v7.8.jpg}{}{0.75}{}
\img{img/v7.9.jpg}{}{0.75}{}
\sse{Anforderungen Verzeichnisdienste}
\uli{
	\li Verwalten einer grossen Zahl von Namen
	\li Lange Lebensdauer des Dienstes
	\li Hohe Verfügbarkeit.
	\li Isolierung von Fehlern. \\Ein Fehler darf sich nicht global auswirken
	\li Tolerierung von Misstrauen: \\in komplexen Netzwerken (Beispiel Internet) sind nicht alle Teilnehmer bekannt. Es muss also mit Misstrauen gerechnet werden, weil nicht
alle alles kennen können.
}

\se{Namesauflösung}
\expl{Iterative Namensauflösung}{Client ruft einer nach dem Andern auf}
\expl{Rekursive Namensauflöung}{Client ruft einer auf, dieser ruft andere auf, wenn er es nicht weis}

\img{img/v7.10.jpg}{}{0.75}{}

\sse{Discovery und Directory Service}
\img{img/v7.11.jpg}{}{0.75}{}

\se{LDAP}
\img{img/v7.12.jpg}{}{0.75}{}
\img{img/v7.13.jpg}{}{0.75}{}

\uli{
	\li Suchen muss schnell sein
	\li Eintragen, modifizieren und löschen müssen nicht so schnell seins
}

\img{img/v7.14.jpg}{Namensauflösung}{0.75}{}
\img{img/v7.15.jpg}{Schema}{0.75}{}

\img{img/v7.16.jpg}{LDAP logisches Modell}{0.75}{}
\exam{LDAP Übungsbeispiel kommt an Prüfung. LDAP Struktur verstehen und definieren können}

\se{JNDI Java Naming and Directory Interface API}
\img{img/v7.17.jpg}{}{0.75}{}


\ch{P2P}
\uli{
	\li Grosse Anzahl Teilnehmer
	\li Teilnehmer oft nicht ausgelastet
	\li Daten und Ressourcen werden möglichst redundant verteilt
	\li sollte selbstorganisierend sein
	\li Kein zentrale Zugriffskontrolle, Backup, etc.
	\li Jeder Knoten ist gleichberechtigt, kein hirarchischer Aufbau
	\li Hauptherausforderung: Zusammenschliessen des ganzen, o(n) zu durchbrechen
	\li muss immer verfügbar sein
}
\img{img/v8.1.jpg}{Client/Server vs P2P}{0.75}{}
\sse{Vorteile}
\uli{
	\li Robustheit
	\li dynamische Reorganisation
}

\sse{Probleme}
\uli{
	\li Aufbau von solchen Netzen
	\li Wiederauffinden von Informationen, weil sich das Netz dauernd ändert
}

\sse{Aufgaben}
\uli{
	\li Ressourcen müssen global eindeutig gekennzeichnet sein
	\li Speichern von verteilte Objekten
}
\sse{Overlay Routing}
\img{img/v8.2.jpg}{IP vs Overlay Routing}{0.75}{}

\expl{Schlüsselproblem P2P}{Effizienter Zugriff auf die gewünschten Daten}

\se{Routing Overlay}
\uli{
	\li steht weit über IP
	\li Kombination mehrere Schemen
	\li Jeder Knoten kann auf jedes Informationsobjekt zugreifen
	\li Jeder Knoten enthält Informationen über die redundant abgelegten Objekte
}
\img{img/v8.3.jpg}{Routing Problem}{0.75}{}

\sse{Operationen}
\uli{
	\li Informationen einfügen
	\li Informationen abfragen
	\li Informationen löschen
}
\img{img/v8.4.jpg}{}{0.75}{}
\img{img/v8.5.jpg}{}{0.75}{}

\se{Pastry, Tapstry}
\uli{
	\li Jeder Knoten besitzt leaf set (Nachbarn)
	\li App wird benachrichtigt, falls neue Nachbarn erreichbar sind oder wegfallen
}

\img{img/v8.6.jpg}{Zirkuläres Routing - korrekt aber ineffizient}{0.75}{}
\img{img/v8.7.jpg}{Pastry Routing - nicht sehr effizient}{0.75}{}
\img{img/v8.8.jpg}{Pastry Node State}{0.75}{}
\img{img/v8.9.jpg}{Pastr Routing Algorithmus}{0.75}{}
\img{img/v8.10.jpg}{Beispiel}{0.75}{}


\se{Verteiltes Hashing DHT}
\img{img/v8.11.jpg}{}{0.75}{}
\img{img/v8.12.jpg}{DHT Factoring}{0.75}{}

\sse{Lookup}
\img{img/v8.13.jpg}{Lookup problem}{0.75}{}
\img{img/v8.14.jpg}{Basic Lookup}{0.75}{}

\sse{Finger Table}
\img{img/v8.15.jpg}{}{0.75}{}
\img{img/v8.16.jpg}{}{0.75}{}
\img{img/v8.17.jpg}{O(log(N))}{0.75}{}



\ch{Zeit und globale Zustände}
\se{Logische Uhr}
\expl{globale Uhr}{in Verteilten Systemen gibt es keine globale Uhr!}
\expl{logische Uhr}{Definierung der Zeit aufgrund einer Abfolge von physischen Abfolgen}
\img{img/v9.1.jpg}{Prozessnachrichtendiagramm, p:Prozess, e: Ereignis, m: Message}{0.75}{}
\exam{Prozessnachrichtendiagramm kommt an Prüfung ganz sicher}
\uli{
	\li Historie für jeden Prozess ist die Menge seiner Ereignisse
	\li $history(p_i)=(e_i^0, e_i^1, e_i^2, ...)$

}
\exam{Physische Zeit ist nicht prüfungsrelevant, Aufgabe mit logischer Zeit kommt eine Aufgabe an Prüfung}
\important{Zeit darf nie zurückgestellt werden! \ra Datenbanken, etc. crashen, Message Chaos vorprogrammiert}
\uli{
	\li Logische Zeit: Keine fest definierte Zeit, nur Ereignisreihenfolge
	\li ``Happend Before'' Beziehung definiert Zeit: \img{img/v9.2.jpg}{}{0.75}{}
	\li Senden muss immer vor dem Empfangen geschehen!
}
\img{img/v9.3.jpg}{Formale Definition der Relation}{0.8}{}
\img{img/v9.4.jpg}{}{0.8}{}
\uli{
	\li Initialisierung der Zeit mit 1
	\li Lokals Ereignis inkrementiert Zeit
	\li Beim Senden wird Zeit mitgeschickt
	\li Beim Empfangen wird max(Lokalen, Empfangenen Zeit) + 1 genommen
	\li Gerechnet wird immer nur vorwärts (Halbordnung)
}
\img{img/v9.5.jpg}{Beispiel Lamport Zeit}{0.75}{}
\uli{
	\li	aus a->b folgt C(a)->C(b)
	\li ABER: aus C(a)->C(b) folgt NICHT a->b
	\li Rückschlüsse sind nicht möglich
}
 
\sse{Vectorclock}
\uli{
	\li Jeder Prozess hält Vektor mit Zeiten der andern Prozessen und des eigenen
	\li Problem, dass man nicht weis, wie viele Prozesse / aktive Komponenten in einem System vorhanden sind
	\li Praktisch alle Datenbanken locken basierend auf Lamport Zeit
	\li Beim Empfang wird das Maximum, nicht das Max+1 genommen
}
\img{img/v9.6.jpg}{Vectorclock}{0.75}{}
\definition{Vectorclock}{\img{img/v9.7.jpg}{Vectorclock}{0.75}{}}

\img{img/v9.8.jpg}{Vectorclock Algorithmus. Tipp: als erstes für jeden Prozess für jeden Punkt seine Vektorposition durchnummerieren}{0.75}{}

\exam{Typische Prüfungsaufgabe \img{img/v9.9.jpg}{Vectorclock}{0.75}{}}
 
 
\se{Globale Zustände}
\uli{
	\li Besteht aus Prozess und Kanalzustand
	\li Die Aktualisierungsnachrichten von zwei Zuständen können sich überschneiden \ra inkonsistenter Zustand
	\li Markernachrichten werden durch das ganze System durchgeschickt und mit dem lokalen Zustand weitergeschickt 
	\li Zustand ist konsistent weil der Sender eine Bestätigung erhält
		\img{img/v9.11.jpg}{Es werden nur Ereignisse berücksichtigt werden, die eine kausale Abhängigkeit besitzen}{0.75}{}
	\li Selbst wenn sich der Zustand von p1 nach dem Bekanntgeben seines aktuellen Zustandes ändern, werden diese Änderungen ignoriert und der Zustand ist eingefroren bis die Änderung bestätigt wird
	\li Der Logische Zustand entspricht nie dem Physischen Zustand!
	\li Kanäle sind FIFO und unidirektional
}
\img{img/v9.10.jpg}{Abgleich eines globalen Zustandes zwischen zwei Prozessen}{0.75}{}
\img{img/v9.14.jpg}{Algorithmus zum Finden eines globalen Zustandes}{0.75}{}
 
\img{img/v9.12.jpg}{}{0.75}{}
\img{img/v9.13.jpg}{}{0.75}{}
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 


\end{document}
